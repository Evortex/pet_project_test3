# Урок 5: REST API, Слои, Веб-интерфейс

В этом уроке тебе предстоит описать REST API маршруты, бизнес логику и подключить веб-интерфейс 
к CRUD веб-сервису для работы проектами. Данное приложение работает на одном из популярных Python REST фреймворков - FastAPI.

## Задание:

1. Открой [project_router.py](app/routers/project_router.py) и ознакомься с кодом, внимательно изучи как устроены методы.

2. На строке 50 напиши обработчик маршрута '/{id}', функцию get_project_by_id, которая будет возвращать страницу проекта по его id.

3. Открой [main.py](app/main.py) и ознакомься со строчкой 18, где на этапе создания FastAPI приложения подключается 
роутер для обработки всех путей, начинающихся с '/project'.

4. Открой [project_service.py](app/services/project_service.py), также ознакомься с кодом и внимательно его изучи.

5. На строке 37 напиши функцию get_project_by_id, которая будет обращаться к базе данных и возвращать проект по его id.

Что-ж, отлично, теперь ты знаешь как работают слои и маршруты в FastAPI. 
Если ты захочешь проверить список маршрутов доступных в твоем приложении, 
просто открой страницу [/docs](http://localhost:8080/docs) в браузере с OpenAPI документацией.
Если пользователь захочет просмотреть данные проекта, на сайте он обратится на страницу /project/{id}, 
его запрос будет принят соответствующим обработчиком маршрута, тот в свою очередь вызовет функцию из сервиса,
внутри которой выполнится бизнес-логика по получению проекта из базы данных.
Настоятельно рекомендуем ознакомиться с тем как работают CRUD методы в приложении.  

Самая важная часть - описание логики работы на бэке, уже готова, но как ты знаешь, REST API - это интерфейс для 
общения сервисов друг с другом, а не людей. В ответ он отправляет не слишком человекочитаемые JSON-объекты. 
Давай попробуем это исправить и подключить удобный веб-интерфейс, те самые html/css/javascript страницы, 
с которыми ты работал в первом уроке. Как мы говорили ранее, в настоящее время популярной является концепция 
клиент-серверной архитектуры, но сегодня мы отойдем от REST и реализуем другой подход - SSR. 
Server Side Rendering подход объединяет в себе логику работы backend и frontend в одном приложении, запущенном на сервере,
которое отдает клиенту готовые отрендеренные страницы. Такое решение является не совсем современным, 
однако до сих пор используется многими веб-сервисами, и поэтому о нем полезно знать. 

Поможет нам в этом библиотека Jinja2Templates, она позволяет интегрировать в html файлы небольшие куски Python кода
и превращать шаблон в готовую красивую страницу. Давай попробуем это сделать.

6. Открой [template.py](app/template.py) ознакомься с кодом подключения движка для рендеринга html-страниц
и укажи путь к папке с шаблонами.
```
="templates"
```

7. Снова перейди в [main.py](app/main.py), на строчке 41 напиши возврат рендера главной страницы сайта index.html.
В качестве примера можешь использовать код из [project_router.py](app/routers/project_router.py).
```
("index.html", ...)
```

8. Открой [projects.html](app/templates/projects.html) и ознакомься с кодом, начиная с 95 строки,
изучи как устроены циклы и вывод переменных в Jinja2Templates.

9. Запусти Docker, останови и удали старый контейнер, также удали image, затем создай новый контейнер с помощью docker-compose,
запусти приложение и перейди по адресу http://localhost:8080/. Ты должен увидеть главную страницу сайта.

10. Также обязательно просмотри весь код проекта, мы специально оставили комментарии, которые помогут тебе разобраться в нем. 


Поздравляем! У тебя получилось создать и запустить полноценное веб-приложение,
которое работает с базой данных и имеет удобный веб-интерфейс. 
В следующем уроке мы подключим к нему GPT, а после развернем на стороннем сервере,
чтобы оно стало доступно в интернете.


### Важные примечания:

1. Для того чтобы корректно начать работу зайди в настройки 
(File-->Settings-->Project-->ProjectStructure) и пометь директорию app в качестве Sources. 
Это нужно, чтобы программа могла правильно видеть файлы внутри проекта.
2. Перед запуском проекта не забудь установить все зависимости из Pipfile.lock.
3. Пиши свой код только внутри отведенных областей между комментариями, 
каждая область помечена номером, соответствующим номеру задания и содержит обозначения границ ("начало" и "конец").
4. Пользуйся поисковыми системами и сервисом Chat GPT, чтобы быстрее находить решения.


###### В директории examples ты можешь найти решения заданий, но мы рекомендуем попытаться решить их самостоятельно.